# minitalk
# Minitalk

C言語とUNIXシグナル（`SIGUSR1`、`SIGUSR2`）だけを使って、ビット単位でメッセージを送受信するクライアント–サーバープログラムです。

---

## 📋 概要

- **目的**  
  - `server`（受信側）と `client`（送信側）の2つの実行ファイルを実装し、UNIXシグナルで文字列をやり取りする。  
  - 1回のシグナル送信で「0ビット」または「1ビット」を表現し、8ビットを組み合わせて1文字（1バイト）として復元する。  
- **言語**  
  - C言語（42のNormに準拠）  
- **仕組みの流れ**  
  1. クライアントは文字列を1文字ずつ取り出し、各文字を8ビットに分解する  
  2. 各ビットを送信する際、`SIGUSR1` を“0ビット”、`SIGUSR2` を“1ビット”としてサーバーに送る  
  3. サーバーは受け取ったシグナルをビット列として蓄積し、8ビットそろったら1文字に復元して表示する  

---

## 📖 用語・概念

| 用語                      | 意味・役割                                                                                                                                         |
|---------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------|
| **プロセス**              | 実行中のプログラムのインスタンス。OS上で動く「仕事単位」を指す。                                                                                      |
| **PID (プロセスID)**      | OSが各プロセスに割り当てる一意の整数。`kill(target_pid, SIGNAL)` でシグナル送信先を指定する際に使う。                                                  |
| **UNIXシグナル**          | プロセス間で通知や割り込みを伝える仕組み。例：`SIGINT`（Ctrl+C割り込み）や今回の `SIGUSR1`、`SIGUSR2` など。                                           |
| **SIGUSR1 / SIGUSR2**     | ユーザー向けに予約されたシグナル。Minitalkでは「SIGUSR1＝1ビット」「SIGUSR2＝0ビット」として使い、ビット単位でデータを送受信する。                  |
| **kill()**                | シグナルを送るシステムコール。`kill(target_pid, SIGNAL)` で、指定した `target_pid` のプロセスに `SIGNAL` を送信する。                              |
| **シグナルハンドラ**      | プロセスがシグナルを受け取った際にOSが呼び出す関数。`sigaction()` や `signal()` で登録し、受信したシグナルに応じてビットを蓄積するなどの処理を行う。 |
| **pause()**               | シグナルが来るまでプロセスを一時停止する関数。シグナルを受け取るとハンドラを実行し、その後 `pause()` が戻って再び待機状態になる。                       |
| **usleep()**              | マイクロ秒（百万分の一秒）単位でプロセスを一時停止させる関数。シグナル送信間隔を少し空けることで、連続送信時に同じシグナルが消える問題を回避する。       |


| **ビット／バイト**        |
 - **ビット**：最小のデータ単位で “0” か “1”。  
 - **バイト**：8ビットをまとめたもの。1バイトで1文字（ASCIIなど）を表現する。  
 - Minitalkでは1回のシグナルで1ビットを送り、8シグナルで1文字を再構築する。

| 用語                        | 意味・役割                                                                                                                                                       |
|-----------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **グローバル変数**          | ファイル全体で共有できる変数。Minitalkでは「受信中のビット列を蓄積」するために1つだけ許可される（プログラムごとに1つ）。                                        |
| **Norm**                    | 42校独自のコーディング規約。インデント、命名規則、行長などが厳格に定められており、違反すると評価が0点となる。                                                      |
| **Makefile**                | ソースコードをコンパイル・リンクするための設定ファイル。`all`、`clean`、`fclean`、`re`、（ボーナス用に）`bonus` のターゲットを定義し、ビルドを自動化する。         |
| **セグメンテーションフォルト** | メモリ領域への不正アクセスによりプログラムが異常終了するエラー。起動時や実行中に起きると採点が0点となる。                                                          |
| **メモリリーク**            | `malloc()` で確保したメモリを `free()` せずに放置し続けること。メモリリークがあると評価で減点または0点になる。                                                      |
| **Unicode (UTF-8)**         | 日本語などの多バイト文字を扱う文字コード。ボーナス要件で「UTF-8文字列をビット単位で送受信」すると加点される。                                                        |


## 📚 仕組みの詳細

以下では、サーバー側・クライアント側の処理フローを、見やすく段階的に説明します。

---

### 1. サーバーの初期化 / 待機

1. **PIDの表示**  
   - `getpid()` を呼び出し、自分（サーバー）の PID を取得  
   - 取得した PID を画面に表示  
     ```c
     pid_t pid = getpid();
     printf("Server PID: %d\n", pid);
     ```

2. **シグナルハンドラの登録**  
   - `sigaction()`（または `signal()`）で、  
     - `SIGUSR1` 用ハンドラ  
     - `SIGUSR2` 用ハンドラ  
     をそれぞれ登録する  
   - 例（略式）：
     ```c
     struct sigaction sa;
     sa.sa_sigaction = &handle_signal;
     sa.sa_flags = SA_SIGINFO;
     sigemptyset(&sa.sa_mask);
     sigaction(SIGUSR1, &sa, NULL);
     sigaction(SIGUSR2, &sa, NULL);
     ```

3. **シグナル待機ループ**  
   - メインループで `pause()` を呼び続けて、  
     シグナルが来るまで一時停止する  
   - 受信したシグナルをハンドラで処理し、処理後にまた `pause()` に戻る  
     ```c
     while (1) {
         pause(); // シグナル受信を待つ
     }
     ```

---

### 2. クライアントの送信処理

1. **引数チェック**  
   - `argc == 3` であることを確認  
     ```c
     if (argc != 3) {
         fprintf(stderr, "Usage: %s <server_pid> <message>\n", argv[0]);
         return 1;
     }
     ```
   - `argv[1]`：サーバー PID  
   - `argv[2]`：送信する文字列

2. **文字列をビットに分解**  
   - 文字列中の各文字を取り出し、1バイト（8ビット）ごとに分解する  
     ```c
     char *msg = argv[2];
     for (int idx = 0; msg[idx] != '\0'; idx++) {
         unsigned char ch = msg[idx];
         for (int bit_index = 7; bit_index >= 0; bit_index--) {
             int bit = (ch >> bit_index) & 1;
             // 以下でシグナルを送信
         }
     }
     ```

3. **ビットごとにシグナル送信**  
   - **0ビット** の場合：  
     ```c
     kill(server_pid, SIGUSR1);
     ```
   - **1ビット** の場合：  
     ```c
     kill(server_pid, SIGUSR2);
     ```
   - **連続シグナルの消失を防ぐ**ため、ビットを送信したあとに小さな遅延を入れる  
     ```c
     usleep(200); // 数百マイクロ秒程度の遅延
     ```

4. **送信完了後の終了**  
   - すべての文字（ビット）を送信し終えたら、プログラムを正常終了する  
     ```c
     return 0;
     ```

---

### 3. サーバーのシグナルハンドラ

1. **シグナル受信**  
   - `handle_signal(int signo, siginfo_t *info, void *context)` などを定義し、  
     - `signo == SIGUSR1` → “0ビット”  
     - `signo == SIGUSR2` → “1ビット”  
     を判定する

2. **ビットバッファへの蓄積**  
   - グローバル変数（ビットバッファ）に文字列形式で “0” または “1” を追加  
   - 例：`static char bit_buffer[9];`（終端 `'\0'` 用に長さ9 など）

3. **1バイト（8ビット）そろったら文字に変換**  
   - 8ビット分たまったら、ビット列を 1バイト（`char`）に変換  
     ```c
     char byte = 0;
     for (int i = 0; i < 8; i++) {
         byte = (byte << 1) | (bit_buffer[i] - '0');
     }
     ```
   - 文字として表示  
     ```c
     write(1, &byte, 1);
     ```

4. **バッファのリセット**  
   - 8ビット処理後はバッファをクリアし、次の文字受信に備える  
     ```c
     memset(bit_buffer, 0, sizeof(bit_buffer));
     bit_count = 0;
     ```

---

### 4. 性能要件

- **100文字を表示するのに1秒以上かかる場合は「遅すぎる」とみなされる**  
  - `usleep()` の遅延を最小限に抑える  
  - 効率的なビット送受信と変換処理を心がける  
  - 目標：およそ **100 chars/sec** 以上のスループット

```markdown
